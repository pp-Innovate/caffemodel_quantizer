#include <iostream>
#include <fstream>
#include <cstring>
#include <string>
#include <vector>
#include <unistd.h>

#include <boost/shared_ptr.hpp>
#include <caffe/caffe.hpp>
#include <caffe/util/io.hpp>
#include <ristretto/base_ristretto_layer.hpp>

#include <opencv2/opencv.hpp>

using namespace std;
using namespace boost;
using namespace caffe;

string proto, weight, picture, mean;
string output_weight_path = "./", output_data_path = "./";

cv::Size input_geometry_;
int num_channels_;
cv::Mat mean_;

void PrintHelpMessage(void);
void SetMean(const string &mean_file);
void WrapInputLayer(vector<cv::Mat> *input_channels, Blob<float> *input_blob);
void Preprocess(const cv::Mat& img, vector<cv::Mat>* input_channels);
void SaveWeightAndBias(string path, string prefix, vector<shared_ptr<Layer<float> > > &ptr_layers);
void SaveFeatureMaps(string path, vector<string> &ptr_blob_names, vector<shared_ptr<Blob<float> > > &ptr_blobs);

int main(int argc, char *argv[])
{
    if(argc == 1)
    {
        PrintHelpMessage();
        return 0;
    }

    /* command line option parse */
    int opt;
    while((opt = getopt(argc, argv, "hm:i:p:e:w:d:")) != -1)
    {
        switch(opt)
        {
            case 'h': PrintHelpMessage();return 0;
            case 'm': proto.assign(optarg);break;
            case 'i': weight.assign(optarg);break;
            case 'p': picture.assign(optarg);break;
            case 'e': mean.assign(optarg);break;
            case 'w': output_weight_path.assign(optarg);break;
            case 'd': output_data_path.assign(optarg);break;
            default: PrintHelpMessage();return 0;
        }
    }

    if(output_weight_path.at(output_weight_path.length() - 1) != '/')
        output_weight_path.append(1, '/');
    if(output_data_path.at(output_data_path.length() - 1) != '/')
        output_data_path.append(1, '/');

    /* load image form file */
    cv::Mat img = cv::imread(picture, -1);
    if(img.empty())
    {
        cout<<"Unable to read image "<<picture<<endl;
        return -1;
    }

    /* load net definition and weights form file */
    Caffe::set_mode(Caffe::CPU);
    Net<float> network(proto, caffe::TEST);
    network.CopyTrainedLayersFrom(weight);

    /* extract some information about network input */
    Blob<float> *input_layer = network.input_blobs()[0];
    num_channels_ = input_layer->channels();
    input_geometry_ = cv::Size(input_layer->width(), input_layer->height());

    /* load the binaryproto file */
    SetMean(mean);

    /* set the shape of input blob */
    input_layer->Reshape(1, num_channels_, input_geometry_.height, input_geometry_.width);

    /* forward dimension change to all layers */
    network.Reshape();

    /* map the image channel to the input blob data address */
    vector<cv::Mat> input_channels;
    WrapInputLayer(&input_channels, input_layer);

    /* preprocessing image and feed data */
    Preprocess(img, &input_channels);

    /* conduct a network inference */
    network.Forward();

    /* extract the pointer array of Layer objects */
    vector<shared_ptr<Layer<float> > > ptr_layers = network.layers();

    /* save weight and bias */
    SaveWeightAndBias(output_weight_path, network.name(), ptr_layers);

    /* extract the array of blob names */
    vector<string> ptr_blob_names = network.blob_names();

    /* extract the pointer array of Blob object */
    vector<shared_ptr<Blob<float> > > ptr_blobs = network.blobs();

    /* save intermediate feature maps */
    SaveFeatureMaps(output_data_path, ptr_blob_names, ptr_blobs);

}

void PrintHelpMessage(void)
{
    cout<<"Usage: ./NetExport [OPTION]... "<<endl;
    cout<<"Export net parameters and intermediate feature maps from 8-bit quantized CNN model. "<<endl;
    cout<<"All paramters are saved into a ordinary binary file with 8-bit char format, and a description text file. "<<endl; 
    cout<<"The start position and length of each layer's parameters can be found in the description file. "<<endl;
    cout<<"The intermediate feature maps are saved into separate binary files with 32-bit float format. "<<endl;
    cout<<"options:"<<endl;
    cout<<" -h\t\tprint this help message."<<endl;
    cout<<" -m\t\tinput quantized model definition .prototxt file."<<endl;
    cout<<" -i\t\tinput quantized model weight .caffemodel file generated by ConvertCaffemodel."<<endl;
    cout<<" -p\t\ttest image which will be fed into the network."<<endl;
    cout<<" -e\t\tinput mean file."<<endl;
    cout<<" -w\t\tpath to store the output parameter files."<<endl;
    cout<<" -d\t\tpath to store the output feature map files."<<endl;

}

void SetMean(const string &mean_file)
{
    /* load the mean file in binaryproto format */
    BlobProto blob_proto;
    ReadProtoFromBinaryFileOrDie(mean_file.c_str(), &blob_proto);

    /* convert from BlobProto to Blob<float>  */
    Blob<float> mean_blob;
    mean_blob.FromProto(blob_proto);

    /* the format of the mean file is planar 32-bit float BGR or grayscale */
   vector<cv::Mat> channels;
   float *data = mean_blob.mutable_cpu_data();
   for(int i = 0; i < num_channels_; i++)
   {
        /* extract an individual channel */ 
       cv::Mat channel(mean_blob.height(), mean_blob.width(), CV_32FC1, data);
       channels.push_back(channel);
       data += mean_blob.height() * mean_blob.width();
   }

   /* merge the separate channels into a single image */
   cv::Mat mean;
   cv::merge(channels, mean);

   /* compute the global mean pixel value and create a mean image filled with this value */
   cv::Scalar channel_mean = cv::mean(mean);
   mean_ = cv::Mat(input_geometry_, mean.type(), channel_mean);
}

void WrapInputLayer(vector<cv::Mat> *input_channels, Blob<float> *input_blob)
{
    int width = input_blob->width();
    int height = input_blob->height();
    float *input_data = input_blob->mutable_cpu_data();

    for(int i = 0; i < input_blob->channels(); i++)
    {
        cv::Mat channel(height, width, CV_32FC1, input_data);
        input_channels->push_back(channel);
        input_data += width * height;
    }
}

void Preprocess(const cv::Mat& img, vector<cv::Mat>* input_channels)
{
    cv::Mat sample = img;

    /* resize the image to fit the network input blob */
    if(sample.size() != input_geometry_)
        cv::resize(sample, sample, input_geometry_);    

    /* mean value removing */
    cv::Mat sample_float;
    sample.convertTo(sample_float, CV_32FC3);
    cv::subtract(sample_float, mean_, sample_float);

    /* feed the image data into network input blob */
    cv::split(sample_float, *input_channels);
}

void SaveWeightAndBias(string path, string prefix, vector<shared_ptr<Layer<float> > > &ptr_layers)
{
    string binary_filename = path + prefix + "_8bit.dat";
    string text_filename = path + prefix + "_description.txt";

    ofstream binfile(binary_filename.c_str(), ios::out | ios::binary | ios::trunc);
    ofstream txtfile(text_filename.c_str(), ios::out | ios::trunc);

    txtfile<<"layer\t\tweight/bias\tstart\t\tlength\t\tfl_param"<<endl;

    long position;

    cout<<"exporting weight and bias ..."<<endl;

    /* save weight and bias of each RistrettoLayer */
    for(int i = 0; i < ptr_layers.size(); i++)
    {
        /* extract LayerParameter object of current layer */ 
        LayerParameter lp = ptr_layers[i]->layer_param();

        /* if current layaris not a RistrettoLayer, there is no need to save */
        if(!lp.has_quantization_param())
            continue;

        /* obtain the Ristretto-defined QuantizationParameter */
        int bw_params = lp.quantization_param().bw_params();
        int fl_params = lp.quantization_param().fl_params();

        cout<<" Layer #"<<i<<" : "<<lp.name()<<" : "<<lp.type();
        cout<<"\tbw_params: "<<bw_params<<"\tfl_params: "<<fl_params<<endl;

        /* extract the pointer array of parameter blobs */
        vector<shared_ptr<Blob<float> > > weight_bias = ptr_layers[i]->blobs();

        /* obtain the position to write */
        position = binfile.tellp();

        /* write description of current layer */
        txtfile<<lp.name()<<"\t\t"<<"weight"<<"\t\t"<<position<<"\t\t"<<weight_bias[0]->count()<<"\t\t"<<fl_params<<endl;

        /* create a write buffer for weight */
        char *write_buffer = new char[weight_bias[0]->count()];

        /* scale and cast the original weight value to 8-bit char type */
        for(int j = 0; j < weight_bias[0]->count(); j++)
            write_buffer[j] = weight_bias[0]->cpu_data()[j] * pow(2, fl_params);

        /* stream 8-bit weight to file */
        binfile.write((const char*)write_buffer, weight_bias[0]->count());

        /* obtain the position to write */
        position = binfile.tellp();

        /* write description of current layer */
        txtfile<<lp.name()<<"\t\t"<<"bias"<<"\t\t"<<position<<"\t\t"<<weight_bias[1]->count()<<"\t\t"<<fl_params<<endl;

        /* realloc a write buffer for bias */
        delete[] write_buffer;
        write_buffer = new char[weight_bias[1]->count()];

        /* scale and cast the original bias value to 8-bit char type */
        for(int j = 0; j < weight_bias[1]->count(); j++)
            write_buffer[j] = weight_bias[1]->cpu_data()[j] * pow(2, fl_params);

        /* stream 8-bit bias to file */
        binfile.write((const char*)write_buffer, weight_bias[1]->count());

        delete[] write_buffer;
    }

    cout<<"done."<<endl;

    binfile.close();
    txtfile.close();
}

void SaveFeatureMaps(string path, vector<string> &ptr_blob_names, vector<shared_ptr<Blob<float> > > &ptr_blobs)
{
    cout<<"exporting intermediate feature maps ..."<<endl;

    /* iteration on each blob */
    for(int i = 0; i < ptr_blobs.size(); i++)
    {
        /* replac '/' in blob name string by '_', then constract a file name */
        string temp = ptr_blob_names[i];
        while(1)
        {
            int pos = temp.find('/');
            if(pos == string::npos)
                break;

            temp.replace(pos, 1, 1, '_');
        }
        string binary_filename = path + temp + ".dat";

        cout<<" Blob #"<<i<<" : "<<ptr_blob_names[i]<<" : "<<ptr_blobs[i]->shape_string()<<endl;

        ofstream binfile(binary_filename.c_str(), ios::out | ios::binary | ios::trunc);

        /* stream 32-bit feature maps to file */
        binfile.write((const char*)ptr_blobs[i]->cpu_data(), ptr_blobs[i]->count() * 4);

        binfile.close();
    }

    cout<<"done."<<endl;
}
